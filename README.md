# Privacy-preserving TEE protoype on a service-oriented environment

***

## Prepare dependencies:

### Build linux-sgx and linux-sgx-driver

 - Please refer to https://github.com/intel/linux-sgx and https://github.com/intel/linux-sgx-driver.
 - Make sure the SGXSDK version is 2.5 or later.
 - In case the current directory structure of SGXSDK changes, you can use the forked 2.6 version (intact) from my Github.
 
```
git clone https://github.com/StanPlatinum/linux-sgx.git
```

### Build libelf

 - We use the libelf from the elfutils (https://sourceware.org/elfutils/). By default it will generate a static library.

```
git clone https://github.com/StanPlatinum/elfutils4sgx.git
cd elfutils4sgx/elfutils-0.176
autoheader
aclocal -I m4
autoconf
automake -a -c
./configure
make
```

### Build capstone

 - Capstone can be cloned at https://github.com/aquynh/capstone. But it is suggested that users can build capstone using our modified version. Capstone by default will generate a static library (capstone.a). To reduce program size, you can configure capstone to only build x86 instruction decoding support.

```
git clone https://github.com/StanPlatinum/capstone.git
cd capstone
mkdir build
mkdir install-x86
cd build
cmake .. -DCMAKE_INSTALL_PREFIX=../install-x86 -DCAPSTONE_ARCHITECTURE_DEFAULT=OFF -DCAPSTONE_X86_SUPPORT=1
make
```

### Build libz

 - Libz is typically already installed in system directory. In case libz.a is not installed, it can be generated by compiling from source (https://zlib.net/).

***

## Usage:

 - To use the prototype, users should first know we have provided a code generator (using LLVM and some linking scripts) and a code execution environment (using Intel SGX).
 - Then users should prepare a crafted source code (in C/C++) for proof generation using our compiler toolset.
 
### Generate target binary from source code
 
#### How to write a crafted SGX application 

 - The entry function is `void enclave()`.
 - The return of an enclave should be `enclave_exit();`.

#### Build compilers

 - Before getting your source code, you should build the following tools.

##### Build llvm/clang

```
git clone https://github.com/StanPlatinum/llvm-project.git
cd llvm-project
mkdir build && cd build
cmake -DLLVM_ENABLE_PROJECTS=clang -DLLVM_TARGETS_TO_BUILD="X86" -G "Ninja" ../llvm
ninja
```
 - This step may take some time...
 - Please modify $(LLVM_PATH) in `dynamic-loader-checker/target-program/ShadowStackCFI/run.sh` to where the LLVM is cloned.
 
##### Build SGX-Shield

 - SGX-Shield is a brilliant work which we have taken advantage of in our project. It can be cloned at https://github.com/jaebaek/SGX-Shield. Also, it is suggested that you can cloned a modified version at https://github.com/StanPlatinum/SGX-Shield.
 - Please modify $(SGX_Shield_PATH) in `dynamic-loader-checker/target-program/Makefile` to where the SGX-Shield is cloned.

#### Prepare the pre-link relocatable binary

 - The general way to generate a relocatable binary with proof is to the following commands:
 
```
cd dynamic-loader-checker/target-program/ShadowStackCFI
bash run.sh
cd ..
make
```

 - Then the `program` and the `entryLabel.txt` has been generated and copied to the dir `dynamic-loader-checker`

### Build the dynamic SGX loader

 - To get your prepared binary checked and run, you should build the SGX dynamic-loader-check first.

#### Copy TCB dependencies to Enclave/TrustedLib

```
cd ..
cp elfutils4sgx/elfutils-0.176/libelf/libelf.a Enclave/TrustedLib
cp capstone/install-x86/lib/libcapstone.a Enclave/TrustedLib
cp /usr/lib/x86_64-linux-gnu/libz.a Enclave/TrustedLib
```

 - Please note that at this time some necessary libs have been copied into the dir Enclave/TrustedLib.

#### Set variables in Makefile

```
cd dynamic-loader-checker
vi Makefile
```

 - Please modify $(SGX_SRC_PATH) to where the SGXSDK is installed.
 - And set $(ELFUTILS_PATH) and $(CAPSTONE_PATH) to where the elfutils and capstone have been installed respectively.

#### Build the sample enclave

```
make
```

#### Try the sample demo

```
./app
```

***

## Try anothor program step by step:

 - You can totally use our toolset to evaluate any other C/C++ programs.
 
 - Firstly, modify your program. You can refer to (### Generate target binary from source code). And put your target unmodified program $(TARGET_NAME).c/cpp in dynamic-loader-checker/target-program/ShadowStackCFI/.
 - SecondlyT, run `make` in ShadowStackCFI/ to generate a directory whose name is $(TARGET_NAME), which includes 5 files in the directory. Run `make` in dynamic-loader-checker/target-program/ to generate the `program` in dynamic-loader-checker/.
 - Thirdly, run `make` in dynamic-loader-checker/ to generate the SGX app that can provide your service. Simply run ./app to get what you want. If your code has data leakage behavior, the SGX app would failed.

 - To re-generate the program, please do `make clean` in both `dynamic-loader-checker/target-program/`.

***

## GL and HF!
